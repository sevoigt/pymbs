import os
import sys
import platform
from subprocess import Popen, PIPE, STDOUT


# f2py.py can be found in .../Pyton26/scripts - must be in your path!

def compileF90(modulename, path, compiler=None):
    '''
    Compile fortran code generated by PyMbs to a python module. We experienced
    this to work best with the mingw32 compiler. Therefore it is hard coded
    below for windows. If you encounter Problems or want to use another
    compiler, change the compiler variable according to your needs.
    '''
    modulename_py=modulename + "_compiledF90"
    try:
        #first delete
        if os.path.isfile(path + '/%s.pyd'%modulename_py):
            os.remove(path + '/%s.pyd'%modulename_py)
        
        # generate platform specific path to f2py and compiler defaults
        opsys = platform.system()

        if opsys == 'Windows':
            binpath = os.path.join(sys.prefix, 'python.exe')
            f2py = binpath + ' -m numpy.f2py'
            comp = '--compiler=mingw32 --skip-empty-wrappers' #--noopt'            

        elif opsys == 'Linux':
            binpath = sys.prefix+"/bin/"
            f2py = binpath + 'f2py'
            comp = ''

        else:
            binpath = ''   # assumes that f2py is somehow accessible from path
            comp = ''

        # use default compiler
        if compiler is None:
            compiler = comp
        #compiler += " --f90flags=-ffree-line-length-none"
        
        # Todo: try compiler flags to handle segfault error in functionmodule.f90
        # source: https://stackoverflow.com/questions/44633519/fortran-strange-segmentation-fault
        compiler += " --f90flags=\"-ffree-line-length-none -fno-stack-arrays -fno-realloc-lhs\""

        # compile
        f2py_call = str.format('{0} -c functionmodule.f90 {1}.f90 -m {2} {3}', 
                                f2py, modulename, modulename_py, compiler)
        print(path)
        print(f2py_call)

        compileProcess = Popen(f2py_call,
                               stdout=PIPE,
                               stderr=STDOUT, 
                               shell=True, 
                               cwd=path)

        while True:
            output = compileProcess.stdout.readline()[:-1]
            if output:
                print(output.decode('UTF-8'))
            if compileProcess.poll() is not None:
                break
        """
        output = compileProcess.communicate()

        if compileProcess.returncode != 0:
            print(output[0])
        else:
            print('Compilation of "%s.f90" successful' % modulename)
        """

    except OSError as e:
        print("Execution failed:", e, file=sys.stderr)
        

def compileC(modulename, path):
    '''
    Compile C code generated by PyMbs to a python module. Compilation is done
    by gcc, which has to be in your PATH.
    '''
    
    try:
        #first delete
        if os.path.isfile(path + '/%s.so'%modulename):
            os.remove(path + '/%s.so'%modulename)
    
        compileProcess = Popen('gcc -shared %s.c -fPIC -o %s.so' % \
                               (modulename, modulename), stdout=PIPE,
                                stderr=STDOUT, shell=True, cwd=path)

        output = compileProcess.communicate()

        if compileProcess.returncode != 0:
            print(output[0])
        else:
            print('Compilation of "%s.c" successful' % modulename)

    except OSError as e:
        print("Execution failed:", e, file=sys.stderr)

    return path + '/%s.so' % modulename
